library(nhppp)
library(ggplot2)
library(dplyr)
library(plotly)
library(ggplot2)

s0.true <- 200
r.true <- 0.2

p1.true <- 0.5
c1.true <- 0.005
m1.true <- 4

p2.true <- 0.2
c2.true <- 0.01
m2.true <- 12

p1.func <- function(t){
  p1.prob <- p1.true/(1+c1.true*(t-m1.true)^2)
  return(p1.prob)
}

p2.func <- function(t){
  p2.prob <- p2.true/(1+c2.true*(t-m2.true)^2)
  return(p2.prob)
}

p3.func <- function(t){
  p3.prob <- 1- p1.true/(1+c1.true*(t-m1.true)^2)-p2.true/(1+c2.true*(t-m2.true)^2)
  return(p3.prob)
}

int.p1.func <- function(t){
  (p1.true/sqrt(c1.true))*(atan(sqrt(c1.true)*(t-m1.true))+atan(sqrt(c1.true)*m1.true))
}

int.p2.func <- function(t){
  (p2.true/sqrt(c2.true))*(atan(sqrt(c2.true)*(t-m2.true))+atan(sqrt(c2.true)*m2.true))
}

int.p3.func <- function(t){
  t-int.p1.func(t) - int.p2.func(t)
}

sc.mean <- function(t){
  s0.true*exp(r.true*(int.p1.func(t)-int.p3.func(t)))
}

sc.var.cnpp <- function(t){
  integrand <- function(x){
    (p1.func(x) + p3.func(x)) * r.true * sapply(x, sc.mean)
  }
  integral.out <- integrate(integrand, 0, t)$value
  return(integral.out)
}

ec.mean <- function(t){
  integrand <- function(x){
    (p2.func(x)+2*p3.func(x))*r.true*sapply(x, sc.mean)
  }
  integral.out <- integrate(integrand,0, t)$value
  return(integral.out)
}

ec.var.cnpp <- function(t){
  integrand <- function(x){
    (p2.func(x) + 4*p3.func(x)) * r.true * sapply(x, sc.mean)
  }
  integral.out <- integrate(integrand, 0, t)$value
  return(integral.out)
}

cov.cnpp <- function(t){
  integrand <- function(x){
    (-2*p3.func(x)) * r.true * sapply(x, sc.mean)
  }
  integral.out <- integrate(integrand, 0, t)$value
  return(integral.out)
}


confidence_ellipse <- function(mu, Sigma, level = 0.95, npoints = 100) {
  if (length(mu) != 2 || !all(dim(Sigma) == c(2, 2))) {
    stop("mu must be a length-2 vector and Sigma must be a 2x2 matrix.")
  }
  
  radius <- sqrt(qchisq(level, df = 2))
  
  eig <- eigen(Sigma)
  angles <- seq(0, 2 * pi, length.out = npoints)
  
  ellipse <- t(eig$vectors %*% diag(sqrt(eig$values)) %*% 
                 rbind(cos(angles), sin(angles))) * radius
  
  ellipse <- sweep(ellipse, 2, mu, "+")
  
  colnames(ellipse) <- c("x", "y")
  return(as.data.frame(ellipse))
}


time.input <- seq(0, 70, by = 0.1)

mean.sc.output <- sapply(time.input, sc.mean)
mean.ec.output <- sapply(time.input, ec.mean)

var.sc.cpnn.output <- sapply(time.input, sc.var.cnpp)
var.ec.cpnn.output <- sapply(time.input, ec.var.cnpp)
cov.cpnn.output <- sapply(time.input, cov.cnpp)

ellipse_dat <- data.frame(time.collected = numeric(),
                          x = numeric(), y = numeric())

theo.dat.plot <- data.frame(time.steps = time.input,
                            sc.steps = mean.sc.output,
                            ec.steps = mean.ec.output,
                            sc.var = var.sc.cpnn.output,
                            ec.var = var.ec.cpnn.output,
                            cov = cov.cpnn.output)

ellipse.dat.plot <- data.frame(time.collected = numeric(),
                               x = numeric(), y = numeric())


for (j in 1:length(time.input)) {
  xc <- theo.dat.plot$sc.steps[j]
  yc <- theo.dat.plot$ec.steps[j]
  cov.mat <- matrix(c(theo.dat.plot$sc.var[j], theo.dat.plot$cov[j],
                      theo.dat.plot$cov[j], theo.dat.plot$ec.var[j]),
                    nrow=2, ncol = 2)
  test.ellipse <- confidence_ellipse(mu = c(xc, yc), Sigma = cov.mat)
  ellipse.dat.plot <- rbind(ellipse.dat.plot, 
                            cbind(rep(time.input[j], nrow = test.ellipse), test.ellipse))
}

colnames(ellipse.dat.plot) <- c("time.collected", "sc.dim", "ec.dim")



plot_ly(ellipse.dat.plot, x = ~time.collected, y = ~sc.dim, z = ~ec.dim,  
        type = "scatter3d", mode = "markers",color = I("skyblue3"))%>%
  layout(scene = list(xaxis = list(title = "time"),
                      yaxis = list(title = "stem cell"),
                      zaxis = list(title = "differentiated cell")))

### simulated data
intensity.func <- function(t){
  r.true * sapply(t, sc.mean)
}

# slope and intercept of the log-linear for thinning algorithm
# need to check if this function is always greater than the intensity function
slope <- -0.008
intercept <- 4

# slope <- -0.008
# intercept <- 3.5
### check intensity function is always smaller than the majorization function
majorization.func <- function(t, a, b){
  out <- exp(a + b*t)
  return(out)
}
input.time <- seq(0, 100)
output.intensity <- output.majorization <- c()
for (i in 1:length(input.time)) {
  output.intensity <- c(output.intensity, intensity.func(input.time[i]))
  output.majorization <- c(output.majorization, 
                           majorization.func(input.time[i], a = intercept, b = slope))
}
dat.majorization <- data.frame(time = input.time,
                               intensity = output.intensity,
                               majorization = output.majorization)
ggplot(data = dat.majorization) +
  geom_line(aes(x = time, y = intensity), color = "indianred")+
  geom_line(aes(x = time, y = majorization), color = "skyblue3")


# simulations settings

f_t1 <- function(t, c1, m1) {
  1 / (1 + c1 * (t - m1)^2)
}

f_t2 <- function(t, c2, m2) {
  1 / (1 + c2 * (t - m2)^2)
}

probs_t <- function(t, p1, p2, c1, c2, m1, m2) {
  f1t <- f_t1(t, c1, m1)
  f2t <- f_t2(t, c2, m2)
  
  p1t <- p1 * f1t
  p2t <- p2 * f2t
  p3t <- 1 - p1t - p2t
  
  if (any(p3t < 0)) warning("Some p3(t) values are negative â€” check parameters!")
  
  cbind(p1t, p2t, p3t)
}

min_p_t <- 0.0001
max_it <- 50000

seed0 <- 922125
t_max <- 100
reps <- 100

set.seed(seed0)
sim <- data.frame(reps = numeric(), time = numeric(), sc = numeric(), ec = numeric())
for (i in 1:reps) {
  # draw event time from the nhppp package using thinning algorithm
  time.draw <- draw_intensity(lambda = intensity.func,
                              line_majorizer_intercept = intercept,
                              line_majorizer_slope = slope,
                              line_majorizer_is_loglinear = TRUE,
                              t_min = 0, t_max = t_max)
  sc.current <- s0.true
  ec.current <- dc.current <- time.current <- 0
  sc.steps <- c(s0.true)
  ec.steps <- c(ec.current)
  # dc.steps <- c(dc.current)
  time.steps <- c(time.current)
  itnum <- 0
  index <- 0
  while (sc.current > 0 & index < length(time.draw)) {
    itnum <- itnum + 1
    index <- index + 1
    time.current <- time.draw[index]
    # calculate proliferation function at event time
    probs <- probs_t(t = time.current, p1 = p1.true, p2 = p2.true, 
                     c1 = c1.true, c2 = c2.true,
                     m1 = m1.true, m2 = m2.true)
    
    if ((sum(probs < min_p_t) > 0 | (itnum > max_it))) {
      cat(q_t, "\n")
      break
    }
    if (sum(probs) > 1) {
      probs <- probs/sum(probs)
    }
    event_type <- sample(1:3, 1, prob=probs)
    switch(event_type,
           "1" = {
             sc.current <- sc.current + 1
             ec.current <- ec.current
           },
           "2" = {
             sc.current <- sc.current
             ec.current <- ec.current + 1
           },
           "3" = {
             sc.current <- sc.current - 1
             ec.current <- ec.current + 2
           })
    sc.steps <- c(sc.steps, sc.current)
    ec.steps <- c(ec.steps, ec.current)
    time.steps <- c(time.steps, time.current)
  }
  sim <- rbind(sim,cbind(reps = rep(i, length(sc.steps)), time.steps, sc.steps, ec.steps))
}

sim %>% filter(reps <= 50) %>% filter(time.steps <= 60) %>%
  ggplot() +
  geom_point(aes(x = time.steps, y = sc.steps), size = 0.2, alpha = 0.05)+
  geom_line(data = theo.dat.plot, aes(x = time.steps, y = sc.steps), 
            col = "red", linewidth = 1.5) +
  geom_ribbon(data = theo.dat.plot, 
              aes(x = time.steps, ymax = sc.steps + 2*sqrt(sc.var), ymin = sc.steps - 2*sqrt(sc.var)),
              fill = "red", alpha = 0.3) +
  # geom_ribbon(data = theoretical.dat, 
  #             aes(x = time, ymax = mean + 2*sqrt(var.cpnn), ymin = mean-2*sqrt(var.cpnn)),
  #             fill = "blue", alpha = 0.2) +
  labs(x = "time", y = "cell counts", title = "CNPP simulated cell counts",
       subtitle = "theoretical mean and bp variance") +
  theme_minimal() 

tms <- seq(0, 70, by = 5)
dat_list <- vector("list", reps)

for (i in seq_len(reps)) {
  sim_sub <- sim %>% filter(reps == i)
  dat_i <- data.frame()
  
  for (j in 2:length(tms)) {
    time.before <- tms[j - 1]
    time.collected <- tms[j]
    
    # Find observations in the time window
    valid_idx <- which(sim_sub$time <= time.collected & sim_sub$time > time.before)
    
    if (length(valid_idx) > 0) {
      ind <- max(valid_idx)  # last observation in the window
      dat_i <- bind_rows(dat_i, cbind(sim_sub[ind, ], time.collected))
    }
  }
  
  dat_list[[i]] <- dat_i
}

dat <- bind_rows(dat_list)

plot_ly(dat, x = ~time.collected, y = ~sc.steps, z = ~ec.steps,  
        type = "scatter3d", mode = "markers", marker = list(size = 2),
        color = I("navyblue")) %>%
  add_trace(x = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(time.collected), 
            y = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(sc.dim),
            z = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(ec.dim), 
            opacity = 0.5, color = I("skyblue3"),
            marker = list(size = 4)) %>%
  layout(scene = list(xaxis = list(title = "time"),
                      yaxis = list(title = "stem cell"),
                      zaxis = list(title = "differentiated cell")))

ggplot() +
  geom_point(data = dat, aes(x = time.collected, y = ec.steps, col = "differentiated cell"), alpha = 0.5)+
  geom_point(data = dat, aes(x = time.collected, y = sc.steps, col = "stem cell"), alpha = 0.5)+
  # geom_point(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
  # geom_point(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
  geom_line(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
  geom_line(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
  geom_ribbon(data = theo.dat.plot, aes(x = time.steps, 
                                   ymin = sc.steps-1.96*sqrt(sc.var), 
                                   ymax = sc.steps+1.96*sqrt(sc.var)), color = "gray", alpha = 0.25)+
  geom_ribbon(data = theo.dat.plot, aes(x = time.steps, ymin = ec.steps-1.96*sqrt(ec.var), 
                                   ymax = ec.steps+1.96*sqrt(ec.var)), color = "gray", alpha = 0.25)+
  labs(x = "time (in hours)", y = "cell counts", color = "",
       title = "Simulated cell counts")+
  scale_color_manual(values = c("differentiated cell" = "skyblue3",
                                "stem cell" = "indianred1",
                                "expected differentiated cell" = "navy",
                                "expected stem cell" = "brown4")) +
  theme_classic() + guides(color = guide_legend(ncol = 2)) +
  theme(legend.position = "bottom", 
        plot.title = element_text(size = 14),
        axis.text.x = element_text(size = 14),
        axis.title.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        legend.text = element_text(size = 13))

### plot branching process
dat_list <- vector("list", reps)

for (i in seq_len(reps)) {
  sim_sub <- sim.markov %>% filter(reps == i)
  dat_i <- data.frame()
  
  for (j in 2:length(tms)) {
    time.before <- tms[j - 1]
    time.collected <- tms[j]
    
    # Find observations in the time window
    valid_idx <- which(sim_sub$time <= time.collected & sim_sub$time > time.before)
    
    if (length(valid_idx) > 0) {
      ind <- max(valid_idx)  # last observation in the window
      dat_i <- bind_rows(dat_i, cbind(sim_sub[ind, ], time.collected))
    }
  }
  
  dat_list[[i]] <- dat_i
}

dat <- bind_rows(dat_list)


plot_ly(dat, x = ~time.collected, y = ~sc.steps, z = ~ec.steps,  
        type = "scatter3d", mode = "markers", marker = list(size = 2),
        color = I("navyblue")) %>%
  add_trace(x = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(time.collected), 
            y = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(sc.dim),
            z = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(ec.dim), 
            opacity = 0.5, color = I("skyblue3"),
            marker = list(size = 4)) %>%
  layout(scene = list(xaxis = list(title = "time"),
                      yaxis = list(title = "stem cell"),
                      zaxis = list(title = "differentiated cell")))

ggplot() +
  geom_point(data = dat, aes(x = time.collected, y = ec.steps, col = "differentiated cell"), alpha = 0.5)+
  geom_point(data = dat, aes(x = time.collected, y = sc.steps, col = "stem cell"), alpha = 0.5)+
  # geom_point(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
  # geom_point(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
  geom_line(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
  geom_line(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
  geom_ribbon(data = theo.dat.plot, aes(x = time.steps, 
                                        ymin = sc.steps-1.96*sqrt(sc.var), 
                                        ymax = sc.steps+1.96*sqrt(sc.var)), color = "gray", alpha = 0.25)+
  geom_ribbon(data = theo.dat.plot, aes(x = time.steps, ymin = ec.steps-1.96*sqrt(ec.var), 
                                        ymax = ec.steps+1.96*sqrt(ec.var)), color = "gray", alpha = 0.25)+
  labs(x = "time (in hours)", y = "cell counts", color = "",
       title = "Simulated cell counts")+
  scale_color_manual(values = c("differentiated cell" = "skyblue3",
                                "stem cell" = "indianred1",
                                "expected differentiated cell" = "navy",
                                "expected stem cell" = "brown4")) +
  theme_classic() + guides(color = guide_legend(ncol = 2)) +
  theme(legend.position = "bottom", 
        plot.title = element_text(size = 14),
        axis.text.x = element_text(size = 14),
        axis.title.x = element_text(size = 14),
        axis.text.y = element_text(size = 14),
        axis.title.y = element_text(size = 14),
        legend.text = element_text(size = 13))
