if (length(valid_idx) > 0) {
ind <- max(valid_idx)  # last observation in the window
dat_i <- bind_rows(dat_i, cbind(sim_sub[ind, ], time.collected))
}
}
dat_list[[i]] <- dat_i
}
# Combine all replicates
dat <- bind_rows(dat_list)
View(dat)
plot_ly(dat, x = ~time.collected, y = ~sc.steps, z = ~ec.steps,
type = "scatter3d", mode = "markers", marker = list(size = 2),
color = I("navyblue"))
head(theo.dat.plot)
head(ellipse.dat.plot)
plot_ly(ellipse.dat.plot, x = ~time.collected, y = ~sc.dim, z = ~ec.dim,
type = "scatter3d", mode = "markers",color = I("skyblue3"))%>%
layout(scene = list(xaxis = list(title = "time"),
yaxis = list(title = "stem cell"),
zaxis = list(title = "differentiated cell")))
plot_ly(dat, x = ~time.collected, y = ~sc.steps, z = ~ec.steps,
type = "scatter3d", mode = "markers", marker = list(size = 2),
color = I("navyblue")) %>%
add_trace(x = ellipse.dat.plot%>%filter(time.collected %in% tms)%>%pull(time.collected),
y = ellipse.dat.plot%>%filter(time.collected %in% tms)%>%pull(sc.dim),
z = ellipse.dat.plot%>%filter(time.collected %in% tms)%>%pull(ec.dim),
opacity = 0.5, color = I("skyblue3"),
marker = list(size = 4)) %>%
layout(scene = list(xaxis = list(title = "time"),
yaxis = list(title = "stem cell"),
zaxis = list(title = "differentiated cell")))
ggplot() +
geom_point(data = dat, aes(x = time.collected, y = ec.steps, col = "differentiated cell"), alpha = 0.5)+
geom_point(data = dat, aes(x = time.collected, y = sc.steps, col = "stem cell"), alpha = 0.5)+
>
ggplot() +
geom_point(data = dat, aes(x = time.collected, y = ec.steps, col = "differentiated cell"), alpha = 0.5)+
geom_point(data = dat, aes(x = time.collected, y = sc.steps, col = "stem cell"), alpha = 0.5)
head(dat)
head(theo.dat.plot)
ggplot() +
geom_point(data = dat, aes(x = time.collected, y = ec.steps, col = "differentiated cell"), alpha = 0.5)+
geom_point(data = dat, aes(x = time.collected, y = sc.steps, col = "stem cell"), alpha = 0.5)+
geom_point(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
geom_point(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps,
ymin = sc.steps-1.96*sqrt(sc.var),
ymax = sc.steps+1.96*sqrt(sc.var)), color = "gray", alpha = 0.25)+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps, ymin = ec.steps-1.96*sqrt(ec.var),
ymax = ec.steps+1.96*sqrt(ec.var)), color = "gray", alpha = 0.25)+
labs(x = "time (in hours)", y = "cell counts", color = "",
title = "Simulated cell counts")+
scale_color_manual(values = c("differentiated cell" = "skyblue3",
"stem cell" = "indianred1",
"expected differentiated cell" = "navy",
"expected stem cell" = "brown4")) +
theme_classic() +
theme(legend.position = "bottom",
plot.title = element_text(size = 14),
axis.text.x = element_text(size = 14),
axis.title.x = element_text(size = 14),
axis.text.y = element_text(size = 14),
axis.title.y = element_text(size = 14),
legend.text = element_text(size = 13))
s0.true <- 200
r.true <- 0.2
p1.true <- 0.5
c1.true <- 0.005
m1.true <- 4
p2.true <- 0.2
c2.true <- 0.01
m2.true <- 12
p1.func <- function(t){
p1.prob <- p1.true/(1+c1.true*(t-m1.true)^2)
return(p1.prob)
}
p2.func <- function(t){
p2.prob <- p2.true/(1+c2.true*(t-m2.true)^2)
return(p2.prob)
}
p3.func <- function(t){
p3.prob <- 1- p1.true/(1+c1.true*(t-m1.true)^2)-p2.true/(1+c2.true*(t-m2.true)^2)
return(p3.prob)
}
int.p1.func <- function(t){
(p1.true/sqrt(c1.true))*(atan(sqrt(c1.true)*(t-m1.true))+atan(sqrt(c1.true)*m1.true))
}
int.p2.func <- function(t){
(p2.true/sqrt(c2.true))*(atan(sqrt(c2.true)*(t-m2.true))+atan(sqrt(c2.true)*m2.true))
}
int.p3.func <- function(t){
t-int.p1.func(t) - int.p2.func(t)
}
sc.mean <- function(t){
s0.true*exp(r.true*(int.p1.func(t)-int.p3.func(t)))
}
sc.var.cnpp <- function(t){
integrand <- function(x){
(p1.func(x) + p3.func(x)) * r.true * sapply(x, sc.mean)
}
integral.out <- integrate(integrand, 0, t)$value
return(integral.out)
}
ec.mean <- function(t){
integrand <- function(x){
(p2.func(x)+2*p3.func(x))*r.true*sapply(x, sc.mean)
}
integral.out <- integrate(integrand,0, t)$value
return(integral.out)
}
ec.var.cnpp <- function(t){
integrand <- function(x){
(p2.func(x) + 4*p3.func(x)) * r.true * sapply(x, sc.mean)
}
integral.out <- integrate(integrand, 0, t)$value
return(integral.out)
}
cov.cnpp <- function(t){
integrand <- function(x){
(-2*p3.func(x)) * r.true * sapply(x, sc.mean)
}
integral.out <- integrate(integrand, 0, t)$value
return(integral.out)
}
confidence_ellipse <- function(mu, Sigma, level = 0.95, npoints = 100) {
if (length(mu) != 2 || !all(dim(Sigma) == c(2, 2))) {
stop("mu must be a length-2 vector and Sigma must be a 2x2 matrix.")
}
radius <- sqrt(qchisq(level, df = 2))
eig <- eigen(Sigma)
angles <- seq(0, 2 * pi, length.out = npoints)
ellipse <- t(eig$vectors %*% diag(sqrt(eig$values)) %*%
rbind(cos(angles), sin(angles))) * radius
ellipse <- sweep(ellipse, 2, mu, "+")
colnames(ellipse) <- c("x", "y")
return(as.data.frame(ellipse))
}
time.input <- seq(0, 70, by = 0.1)
mean.sc.output <- sapply(time.input, sc.mean)
mean.ec.output <- sapply(time.input, ec.mean)
var.sc.cpnn.output <- sapply(time.input, sc.var.cnpp)
var.ec.cpnn.output <- sapply(time.input, ec.var.cnpp)
cov.cpnn.output <- sapply(time.input, cov.cnpp)
ellipse_dat <- data.frame(time.collected = numeric(),
x = numeric(), y = numeric())
theo.dat.plot <- data.frame(time.steps = time.input,
sc.steps = mean.sc.output,
ec.steps = mean.ec.output,
sc.var = var.sc.cpnn.output,
ec.var = var.ec.cpnn.output,
cov = cov.cpnn.output)
ellipse.dat.plot <- data.frame(time.collected = numeric(),
x = numeric(), y = numeric())
for (j in 1:length(time.input)) {
xc <- theo.dat.plot$sc.steps[j]
yc <- theo.dat.plot$ec.steps[j]
cov.mat <- matrix(c(theo.dat.plot$sc.var[j], theo.dat.plot$cov[j],
theo.dat.plot$cov[j], theo.dat.plot$ec.var[j]),
nrow=2, ncol = 2)
test.ellipse <- confidence_ellipse(mu = c(xc, yc), Sigma = cov.mat)
ellipse.dat.plot <- rbind(ellipse.dat.plot,
cbind(rep(time.input[j], nrow = test.ellipse), test.ellipse))
}
colnames(ellipse.dat.plot) <- c("time.collected", "sc.dim", "ec.dim")
plot_ly(ellipse.dat.plot, x = ~time.collected, y = ~sc.dim, z = ~ec.dim,
type = "scatter3d", mode = "markers",color = I("skyblue3"))%>%
layout(scene = list(xaxis = list(title = "time"),
yaxis = list(title = "stem cell"),
zaxis = list(title = "differentiated cell")))
### simulated data
intensity.func <- function(t){
r.true * sapply(t, sc.mean)
}
# slope and intercept of the log-linear for thinning algorithm
# need to check if this function is always greater than the intensity function
slope <- -0.008
intercept <- 4
# slope <- -0.008
# intercept <- 3.5
### check intensity function is always smaller than the majorization function
majorization.func <- function(t, a, b){
out <- exp(a + b*t)
return(out)
}
input.time <- seq(0, 100)
output.intensity <- output.majorization <- c()
for (i in 1:length(input.time)) {
output.intensity <- c(output.intensity, intensity.func(input.time[i]))
output.majorization <- c(output.majorization,
majorization.func(input.time[i], a = intercept, b = slope))
}
dat.majorization <- data.frame(time = input.time,
intensity = output.intensity,
majorization = output.majorization)
ggplot(data = dat.majorization) +
geom_line(aes(x = time, y = intensity), color = "indianred")+
geom_line(aes(x = time, y = majorization), color = "skyblue3")
f_t1 <- function(t, c1, m1) {
1 / (1 + c1 * (t - m1)^2)
}
f_t2 <- function(t, c2, m2) {
1 / (1 + c2 * (t - m2)^2)
}
probs_t <- function(t, p1, p2, c1, c2, m1, m2) {
f1t <- f_t1(t, c1, m1)
f2t <- f_t2(t, c2, m2)
p1t <- p1 * f1t
p2t <- p2 * f2t
p3t <- 1 - p1t - p2t
if (any(p3t < 0)) warning("Some p3(t) values are negative â€” check parameters!")
cbind(p1t, p2t, p3t)
}
min_p_t <- 0.0001
max_it <- 50000
seed0 <- 922125
t_max <- 100
reps <- 100
set.seed(seed0)
sim <- data.frame(reps = numeric(), time = numeric(), sc = numeric(), ec = numeric())
for (i in 1:reps) {
# draw event time from the nhppp package using thinning algorithm
time.draw <- draw_intensity(lambda = intensity.func,
line_majorizer_intercept = intercept,
line_majorizer_slope = slope,
line_majorizer_is_loglinear = TRUE,
t_min = 0, t_max = t_max)
sc.current <- s0.true
ec.current <- dc.current <- time.current <- 0
sc.steps <- c(s0.true)
ec.steps <- c(ec.current)
# dc.steps <- c(dc.current)
time.steps <- c(time.current)
itnum <- 0
index <- 0
while (sc.current > 0 & index < length(time.draw)) {
itnum <- itnum + 1
index <- index + 1
time.current <- time.draw[index]
# calculate proliferation function at event time
probs <- probs_t(t = time.current, p1 = p1.true, p2 = p2.true,
c1 = c1.true, c2 = c2.true,
m1 = m1.true, m2 = m2.true)
if ((sum(probs < min_p_t) > 0 | (itnum > max_it))) {
cat(q_t, "\n")
break
}
if (sum(probs) > 1) {
probs <- probs/sum(probs)
}
event_type <- sample(1:3, 1, prob=probs)
switch(event_type,
"1" = {
sc.current <- sc.current + 1
ec.current <- ec.current
},
"2" = {
sc.current <- sc.current
ec.current <- ec.current + 1
},
"3" = {
sc.current <- sc.current - 1
ec.current <- ec.current + 2
})
sc.steps <- c(sc.steps, sc.current)
ec.steps <- c(ec.steps, ec.current)
time.steps <- c(time.steps, time.current)
}
sim <- rbind(sim,cbind(reps = rep(i, length(sc.steps)), time.steps, sc.steps, ec.steps))
}
sim %>% filter(reps <= 50) %>% filter(time.steps <= 60) %>%
ggplot() +
geom_point(aes(x = time.steps, y = sc.steps), size = 0.2, alpha = 0.05)+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = sc.steps),
col = "red", linewidth = 1.5) +
geom_ribbon(data = theo.dat.plot,
aes(x = time.steps, ymax = sc.steps + 2*sqrt(sc.var), ymin = sc.steps - 2*sqrt(sc.var)),
fill = "red", alpha = 0.3) +
# geom_ribbon(data = theoretical.dat,
#             aes(x = time, ymax = mean + 2*sqrt(var.cpnn), ymin = mean-2*sqrt(var.cpnn)),
#             fill = "blue", alpha = 0.2) +
labs(x = "time", y = "cell counts", title = "CNPP simulated cell counts",
subtitle = "theoretical mean and bp variance") +
theme_minimal()
tms <- seq(0, 70, by = 5)
dat_list <- vector("list", reps)
for (i in seq_len(reps)) {
sim_sub <- sim %>% filter(reps == i)
dat_i <- data.frame()
for (j in 2:length(tms)) {
time.before <- tms[j - 1]
time.collected <- tms[j]
# Find observations in the time window
valid_idx <- which(sim_sub$time <= time.collected & sim_sub$time > time.before)
if (length(valid_idx) > 0) {
ind <- max(valid_idx)  # last observation in the window
dat_i <- bind_rows(dat_i, cbind(sim_sub[ind, ], time.collected))
}
}
dat_list[[i]] <- dat_i
}
# Combine all replicates
dat <- bind_rows(dat_list)
plot_ly(dat, x = ~time.collected, y = ~sc.steps, z = ~ec.steps,
type = "scatter3d", mode = "markers", marker = list(size = 2),
color = I("navyblue")) %>%
add_trace(x = ellipse.dat.plot%>%filter(time.collected %in% tms)%>%pull(time.collected),
y = ellipse.dat.plot%>%filter(time.collected %in% tms)%>%pull(sc.dim),
z = ellipse.dat.plot%>%filter(time.collected %in% tms)%>%pull(ec.dim),
opacity = 0.5, color = I("skyblue3"),
marker = list(size = 4)) %>%
layout(scene = list(xaxis = list(title = "time"),
yaxis = list(title = "stem cell"),
zaxis = list(title = "differentiated cell")))
dat$time.collected
tms
tms[-1]
plot_ly(dat, x = ~time.collected, y = ~sc.steps, z = ~ec.steps,
type = "scatter3d", mode = "markers", marker = list(size = 2),
color = I("navyblue")) %>%
add_trace(x = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(time.collected),
y = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(sc.dim),
z = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(ec.dim),
opacity = 0.5, color = I("skyblue3"),
marker = list(size = 4)) %>%
layout(scene = list(xaxis = list(title = "time"),
yaxis = list(title = "stem cell"),
zaxis = list(title = "differentiated cell")))
ggplot() +
geom_point(data = dat, aes(x = time.collected, y = ec.steps, col = "differentiated cell"), alpha = 0.5)+
geom_point(data = dat, aes(x = time.collected, y = sc.steps, col = "stem cell"), alpha = 0.5)+
geom_point(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
geom_point(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps,
ymin = sc.steps-1.96*sqrt(sc.var),
ymax = sc.steps+1.96*sqrt(sc.var)), color = "gray", alpha = 0.25)+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps, ymin = ec.steps-1.96*sqrt(ec.var),
ymax = ec.steps+1.96*sqrt(ec.var)), color = "gray", alpha = 0.25)+
labs(x = "time (in hours)", y = "cell counts", color = "",
title = "Simulated cell counts")+
scale_color_manual(values = c("differentiated cell" = "skyblue3",
"stem cell" = "indianred1",
"expected differentiated cell" = "navy",
"expected stem cell" = "brown4")) +
theme_classic() +
theme(legend.position = "bottom",
plot.title = element_text(size = 14),
axis.text.x = element_text(size = 14),
axis.title.x = element_text(size = 14),
axis.text.y = element_text(size = 14),
axis.title.y = element_text(size = 14),
legend.text = element_text(size = 13))
head(theo.dat.plot)
ggplot() +
geom_point(data = dat, aes(x = time.collected, y = ec.steps, col = "differentiated cell"), alpha = 0.5)+
geom_point(data = dat, aes(x = time.collected, y = sc.steps, col = "stem cell"), alpha = 0.5)+
# geom_point(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
# geom_point(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps,
ymin = sc.steps-1.96*sqrt(sc.var),
ymax = sc.steps+1.96*sqrt(sc.var)), color = "gray", alpha = 0.25)+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps, ymin = ec.steps-1.96*sqrt(ec.var),
ymax = ec.steps+1.96*sqrt(ec.var)), color = "gray", alpha = 0.25)+
labs(x = "time (in hours)", y = "cell counts", color = "",
title = "Simulated cell counts")+
scale_color_manual(values = c("differentiated cell" = "skyblue3",
"stem cell" = "indianred1",
"expected differentiated cell" = "navy",
"expected stem cell" = "brown4")) +
theme_classic() +
theme(legend.position = "bottom",
plot.title = element_text(size = 14),
axis.text.x = element_text(size = 14),
axis.title.x = element_text(size = 14),
axis.text.y = element_text(size = 14),
axis.title.y = element_text(size = 14),
legend.text = element_text(size = 13))
ggplot() +
geom_point(data = dat, aes(x = time.collected, y = ec.steps, col = "differentiated cell"), alpha = 0.5)+
geom_point(data = dat, aes(x = time.collected, y = sc.steps, col = "stem cell"), alpha = 0.5)+
# geom_point(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
# geom_point(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps,
ymin = sc.steps-1.96*sqrt(sc.var),
ymax = sc.steps+1.96*sqrt(sc.var)), color = "gray", alpha = 0.25)+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps, ymin = ec.steps-1.96*sqrt(ec.var),
ymax = ec.steps+1.96*sqrt(ec.var)), color = "gray", alpha = 0.25)+
labs(x = "time (in hours)", y = "cell counts", color = "",
title = "Simulated cell counts")+
scale_color_manual(values = c("differentiated cell" = "skyblue3",
"stem cell" = "indianred1",
"expected differentiated cell" = "navy",
"expected stem cell" = "brown4")) +
theme_classic() + guides(color = guide_legend(ncol = 2)) +
theme(legend.position = "bottom",
plot.title = element_text(size = 14),
axis.text.x = element_text(size = 14),
axis.title.x = element_text(size = 14),
axis.text.y = element_text(size = 14),
axis.title.y = element_text(size = 14),
legend.text = element_text(size = 13))
min_p_t <- 0.0001
max_it <- 50000
seed0 <- 922125
t_max <- 100
reps <- 100
# simulate data
set.seed(seed0)
sim.markov <- data.frame(reps = numeric(), time = numeric(), sc = numeric(), ec = numeric())
for (i in 1:reps) {
sc.current <- s0.true
ec.current <- dc.current <- time.current <- 0
sc.steps <- c(s0.true)
ec.steps <- c(ec.current)
dc.steps <- c(dc.current)
time.steps <- c(time.current)
itnum <- 0
while (sc.current > 0) {
itnum <- itnum + 1
time.current <- time.current + rexp(1, rate = r.true*sc.current)
probs <- probs_t(t = time.current, p1 = p1.true, p2 = p2.true,
c1 = c1.true, c2 = c2.true,
m1 = m1.true, m2 = m2.true)
if ((sum(probs < min_p_t) > 0 | (itnum > max_it))) {
cat(q_t, "\n")
break
}
if (sum(probs) > 1) {
probs <- probs/sum(probs)
}
event_type <- sample(1:3, 1, prob=probs)
switch(event_type,
"1" = {
sc.current <- sc.current + 1
ec.current <- ec.current
},
"2" = {
sc.current <- sc.current
ec.current <- ec.current + 1
},
"3" = {
sc.current <- sc.current - 1
ec.current <- ec.current + 2
})
sc.steps <- c(sc.steps, sc.current)
ec.steps <- c(ec.steps, ec.current)
time.steps <- c(time.steps, time.current)
}
sim.markov <- rbind(sim.markov,cbind(reps = rep(i, length(sc.steps)), time.steps, sc.steps, ec.steps))
}
### plot branching process
dat_list <- vector("list", reps)
for (i in seq_len(reps)) {
sim_sub <- sim.markov %>% filter(reps == i)
dat_i <- data.frame()
for (j in 2:length(tms)) {
time.before <- tms[j - 1]
time.collected <- tms[j]
# Find observations in the time window
valid_idx <- which(sim_sub$time <= time.collected & sim_sub$time > time.before)
if (length(valid_idx) > 0) {
ind <- max(valid_idx)  # last observation in the window
dat_i <- bind_rows(dat_i, cbind(sim_sub[ind, ], time.collected))
}
}
dat_list[[i]] <- dat_i
}
dat <- bind_rows(dat_list)
plot_ly(dat, x = ~time.collected, y = ~sc.steps, z = ~ec.steps,
type = "scatter3d", mode = "markers", marker = list(size = 2),
color = I("navyblue")) %>%
add_trace(x = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(time.collected),
y = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(sc.dim),
z = ellipse.dat.plot%>%filter(time.collected %in% tms[-1])%>%pull(ec.dim),
opacity = 0.5, color = I("skyblue3"),
marker = list(size = 4)) %>%
layout(scene = list(xaxis = list(title = "time"),
yaxis = list(title = "stem cell"),
zaxis = list(title = "differentiated cell")))
ggplot() +
geom_point(data = dat, aes(x = time.collected, y = ec.steps, col = "differentiated cell"), alpha = 0.5)+
geom_point(data = dat, aes(x = time.collected, y = sc.steps, col = "stem cell"), alpha = 0.5)+
# geom_point(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
# geom_point(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = ec.steps, col = "expected differentiated cell"))+
geom_line(data = theo.dat.plot, aes(x = time.steps, y = sc.steps, col = "expected stem cell"))+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps,
ymin = sc.steps-1.96*sqrt(sc.var),
ymax = sc.steps+1.96*sqrt(sc.var)), color = "gray", alpha = 0.25)+
geom_ribbon(data = theo.dat.plot, aes(x = time.steps, ymin = ec.steps-1.96*sqrt(ec.var),
ymax = ec.steps+1.96*sqrt(ec.var)), color = "gray", alpha = 0.25)+
labs(x = "time (in hours)", y = "cell counts", color = "",
title = "Simulated cell counts")+
scale_color_manual(values = c("differentiated cell" = "skyblue3",
"stem cell" = "indianred1",
"expected differentiated cell" = "navy",
"expected stem cell" = "brown4")) +
theme_classic() + guides(color = guide_legend(ncol = 2)) +
theme(legend.position = "bottom",
plot.title = element_text(size = 14),
axis.text.x = element_text(size = 14),
axis.title.x = element_text(size = 14),
axis.text.y = element_text(size = 14),
axis.title.y = element_text(size = 14),
legend.text = element_text(size = 13))
