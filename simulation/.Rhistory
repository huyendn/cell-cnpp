simulate_markov <- function(
reps = 100,
p1, p2, p4,
c1, c2, c4,
m1, m2, m4,
s0 = 200,
r = 0.2,
min_p_t = 1e-4,
max_it = 50000,
t_max = 100,
seed = NULL
) {
if (!is.null(seed)) set.seed(seed)
f_t <- function(t, c, m) 1 / (1 + c * (t - m)^2)
probs_t <- function(t) {
f1 <- f_t(t, c1, m1)
f2 <- f_t(t, c2, m2)
f4 <- f_t(t, c4, m4)
p1t <- p1 * f1
p2t <- p2 * f2
p4t <- p4 * f4
p3t <- 1 - p1t - p2t - p4t
p3t <- pmax(p3t, 0)
probs <- c(p1t, p2t, p3t, p4t)
s <- sum(probs)
if (s <= 0) stop("All transition probabilities zero — invalid parameters.")
if (s != 1) probs <- probs / s
# avoid extremely small values
probs[probs < min_p_t] <- 0
probs <- probs / sum(probs)
probs
}
all_out <- list()
idx <- 1
for (rep_i in 1:reps) {
sc <- s0
ec <- 0
dc <- 0
t <- 0
itnum <- 0
sc_steps <- sc
ec_steps <- ec
dc_steps <- dc
time_steps <- t
while (sc > 0) {
itnum <- itnum + 1
if (itnum > max_it || t > t_max) {
warning("Stopped early: max_it or time bound exceeded")
break
}
t <- t + rexp(1, rate = r * sc)
probs <- probs_t(t)
event <- sample(1:4, size = 1, prob = probs)
if (event == 1) { sc <- sc + 1 }
if (event == 2) { ec <- ec + 1 }
if (event == 3) { sc <- sc - 1; ec <- ec + 2 }
if (event == 4) { dc <- dc + 1 }
sc_steps <- c(sc_steps, sc)
ec_steps <- c(ec_steps, ec)
dc_steps <- c(dc_steps, dc)
time_steps <- c(time_steps, t)
}
all_out[[idx]] <- data.frame(
reps = rep(rep_i, length(sc_steps)),
time.steps = time_steps,
sc.steps = sc_steps,
ec.steps = ec_steps,
dc.steps = dc_steps
)
idx <- idx + 1
}
do.call(rbind, all_out)
}
sim.markov <- simulate_markov(
reps = reps,
p1 = p1.true, c1 = c1.true, m1 = m1.true,
p2 = p2.true, c2 = c2.true, m2 = m2.true,
p4 = p4.true, c4 = c4.true, m4 = m4.true,
s0 = s0.true,
r = r.true,
seed = 922125
)
head(sim.markov)
## result from differential evolution
# res.de <- read.csv("C:/Users/huyen/OneDrive - University of Connecticut/GDrive/slurm results/destep1_start200_025_005_06_065_012_15_010_008_20_02.csv")
# res.de <- read.csv("C:/Users/huyen/OneDrive - University of Connecticut/GDrive/slurm results/destep1_start200_025_005_06_065_012_15_020_008_20_02.csv")
# res.de <- read.csv("C:/Users/huyen/OneDrive - University of Connecticut/GDrive/slurm results/destep1_start200_030_008_06_030_008_15_030_008_25_02.csv")
res.de <- read.csv("C:/Users/huyen/OneDrive - University of Connecticut/GDrive/slurm results/destep1_start200_055_005_04_015_012_12_010_008_20_02.csv")
res.prm <- data.frame()
start_time <- Sys.time()
for (j in 1:reps) {
sim.data <- data.frame(t = sim.markov$time.steps[sim.markov$reps == j],
Y = sim.markov$ec.steps[sim.markov$reps == j],
M = sim.markov$sc.steps[sim.markov$reps == j] +
sim.markov$dc.steps[sim.markov$reps == j])
data_list <- list(
t = sim.data$t,
M = sim.data$M,
Y = sim.data$Y
)
de.est <- res.de[j,]
parameters <- list(
p1_raw = qlogis(as.numeric(de.est["p1"])),
p2_raw = qlogis(as.numeric(de.est["p2"])),
p4_raw = qlogis(as.numeric(de.est["p4"])),
r_raw  = qlogis(as.numeric(de.est["p1"])),
logit_c1 = qlogis(as.numeric(de.est["c1"]/100)),
logit_c2 = qlogis(as.numeric(de.est["c2"]/100)),
logit_c4 = qlogis(as.numeric(de.est["c4"]/100)),
logit_m1 = qlogis(as.numeric(de.est["m1"]/100)),
logit_m2 = qlogis(as.numeric(de.est["m2"]/100)),
logit_m4 = qlogis(as.numeric(de.est["m4"]/100))
)
obj <- MakeADFun(data_list, parameters, DLL="loglik", silent=TRUE)
# fit <- nlminb(obj$par, obj$fn, obj$gr,
#               control = list(
#                 eval.max = 1000,   # allow more function evaluations
#                 iter.max = 500    # allow more iterations
#                 # rel.tol  = 1e-8,   # convergence tolerance
#                 # x.tol    = 1e-8    # parameter tolerance
#               ))
fit <- optim(obj$par, obj$fn, obj$gr,
method = "BFGS")
est <- fit$par
p1 <- plogis(est["p1_raw"])
p2 <- plogis(est["p2_raw"])
p4 <- plogis(est["p4_raw"])
r  <- plogis(est["r_raw"])
c1 <- 100*plogis(est["logit_c1"])
c2 <- 100*plogis(est["logit_c2"])
c4 <- 100*plogis(est["logit_c4"])
m1 <- 100*plogis(est["logit_m1"])
m2 <- 100*plogis(est["logit_m2"])
m4 <- 100*plogis(est["logit_m4"])
par.est <- c(p1, p2, p4, c1, c2, c4, m1, m2, m4, r)
res.prm <- rbind(res.prm, par.est)
print(j)
}
end_time <- Sys.time()
end_time-start_time
colnames(res.prm) <- c("p1", "p2", "p4", "c1", "c2", "c4",
"m1", "m2", "m4", "r")
res.prm %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
group_by(Variable) %>%
summarise(mean = mean(Value),
median = median(Value),
percentile025 = quantile(Value, probs = 0.025),
percentile975 = quantile(Value, probs = 0.975))
c(p1.true, p2.true, p4.true, c1.true, c2.true, c4.true, m1.true, m2.true, m4.true, r.true, s0.true)
res.prm %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
ggplot(aes(x = "", y = Value)) +
geom_violin(aes(fill = Variable), color = "black") +
geom_boxplot(fill = NA, width = 0.5)+
facet_wrap(~ Variable, scale = "free_y", ncol = 3) +
geom_jitter(width = 0.1, alpha = 0.3) +
theme_minimal() +
labs(title = "Violin Plot for Each Parameter Estimates", x = "",
fill= "Parameters", y = "Estimates")
c(p1.true, p2.true, p4.true, c1.true, c2.true, c4.true, m1.true, m2.true, m4.true, r.true, s0.true)
p1.true <- 0.55
c1.true <- 0.005
m1.true <- 4
p2.true <- 0.15
c2.true <- 0.012
m2.true <- 12
p4.true <- 0.2
c4.true <- 0.008
m4.true <- 20
s0.true <- 200
r.true <- 0.2
reps <- 100
simulate_markov <- function(
reps = 100,
p1, p2, p4,
c1, c2, c4,
m1, m2, m4,
s0 = 200,
r = 0.2,
min_p_t = 1e-4,
max_it = 50000,
t_max = 100,
seed = NULL
) {
if (!is.null(seed)) set.seed(seed)
f_t <- function(t, c, m) 1 / (1 + c * (t - m)^2)
probs_t <- function(t) {
f1 <- f_t(t, c1, m1)
f2 <- f_t(t, c2, m2)
f4 <- f_t(t, c4, m4)
p1t <- p1 * f1
p2t <- p2 * f2
p4t <- p4 * f4
p3t <- 1 - p1t - p2t - p4t
p3t <- pmax(p3t, 0)
probs <- c(p1t, p2t, p3t, p4t)
s <- sum(probs)
if (s <= 0) stop("All transition probabilities zero — invalid parameters.")
if (s != 1) probs <- probs / s
# avoid extremely small values
probs[probs < min_p_t] <- 0
probs <- probs / sum(probs)
probs
}
all_out <- list()
idx <- 1
for (rep_i in 1:reps) {
sc <- s0
ec <- 0
dc <- 0
t <- 0
itnum <- 0
sc_steps <- sc
ec_steps <- ec
dc_steps <- dc
time_steps <- t
while (sc > 0) {
itnum <- itnum + 1
if (itnum > max_it || t > t_max) {
warning("Stopped early: max_it or time bound exceeded")
break
}
t <- t + rexp(1, rate = r * sc)
probs <- probs_t(t)
event <- sample(1:4, size = 1, prob = probs)
if (event == 1) { sc <- sc + 1 }
if (event == 2) { ec <- ec + 1 }
if (event == 3) { sc <- sc - 1; ec <- ec + 2 }
if (event == 4) { dc <- dc + 1 }
sc_steps <- c(sc_steps, sc)
ec_steps <- c(ec_steps, ec)
dc_steps <- c(dc_steps, dc)
time_steps <- c(time_steps, t)
}
all_out[[idx]] <- data.frame(
reps = rep(rep_i, length(sc_steps)),
time.steps = time_steps,
sc.steps = sc_steps,
ec.steps = ec_steps,
dc.steps = dc_steps
)
idx <- idx + 1
}
do.call(rbind, all_out)
}
sim.markov <- simulate_markov(
reps = reps,
p1 = p1.true, c1 = c1.true, m1 = m1.true,
p2 = p2.true, c2 = c2.true, m2 = m2.true,
p4 = p4.true, c4 = c4.true, m4 = m4.true,
s0 = s0.true,
r = r.true,
seed = 922125
)
head(sim.markov)
## optimization
## result from differential evolution
# res.de <- read.csv("C:/Users/huyen/OneDrive - University of Connecticut/GDrive/slurm results/destep1_start200_025_005_06_065_012_15_010_008_20_02.csv")
# res.de <- read.csv("C:/Users/huyen/OneDrive - University of Connecticut/GDrive/slurm results/destep1_start200_025_005_06_065_012_15_020_008_20_02.csv")
# res.de <- read.csv("C:/Users/huyen/OneDrive - University of Connecticut/GDrive/slurm results/destep1_start200_030_008_06_030_008_15_030_008_25_02.csv")
res.de <- read.csv("C:/Users/huyen/OneDrive - University of Connecticut/GDrive/slurm results/destep1_start200_055_005_04_015_012_12_010_008_20_02.csv")
res.de <- read.csv("C:/Users/huyen/OneDrive - University of Connecticut/GDrive/slurm results/destep1_start200_055_005_04_015_012_12_020_008_20_02.csv")
# parameters <- list(
#   p1_raw = qlogis(0.33),
#   p2_raw = qlogis(0.33),
#   p4_raw = qlogis(0.33),
#   r_raw  = qlogis(0.5),
#   logit_c1 = qlogis(1/100),
#   logit_c2 = qlogis(1/100),
#   logit_c4 = qlogis(1/100),
#   logit_m1 = qlogis(10/100),
#   logit_m2 = qlogis(10/100),
#   logit_m4 = qlogis(10/100)
# )
# parameters <- list(
#   p1_raw = qlogis(0.674),
#   p2_raw = qlogis(0.699),
#   p4_raw = qlogis(0.386),
#   r_raw  = qlogis(0.245),
#   log_c1 = log(0.109),
#   log_c2 = log(0.0205),
#   log_c4 = log(0.0689),
#   log_m1 = log(9.71),
#   log_m2 = log(12.8),
#   log_m4 = log(8.11)
# )
res.prm <- data.frame()
start_time <- Sys.time()
for (j in 1:reps) {
sim.data <- data.frame(t = sim.markov$time.steps[sim.markov$reps == j],
Y = sim.markov$ec.steps[sim.markov$reps == j],
M = sim.markov$sc.steps[sim.markov$reps == j] +
sim.markov$dc.steps[sim.markov$reps == j])
data_list <- list(
t = sim.data$t,
M = sim.data$M,
Y = sim.data$Y
)
de.est <- res.de[j,]
parameters <- list(
p1_raw = qlogis(as.numeric(de.est["p1"])),
p2_raw = qlogis(as.numeric(de.est["p2"])),
p4_raw = qlogis(as.numeric(de.est["p4"])),
r_raw  = qlogis(as.numeric(de.est["p1"])),
logit_c1 = qlogis(as.numeric(de.est["c1"]/100)),
logit_c2 = qlogis(as.numeric(de.est["c2"]/100)),
logit_c4 = qlogis(as.numeric(de.est["c4"]/100)),
logit_m1 = qlogis(as.numeric(de.est["m1"]/100)),
logit_m2 = qlogis(as.numeric(de.est["m2"]/100)),
logit_m4 = qlogis(as.numeric(de.est["m4"]/100))
)
obj <- MakeADFun(data_list, parameters, DLL="loglik", silent=TRUE)
# fit <- nlminb(obj$par, obj$fn, obj$gr,
#               control = list(
#                 eval.max = 1000,   # allow more function evaluations
#                 iter.max = 500    # allow more iterations
#                 # rel.tol  = 1e-8,   # convergence tolerance
#                 # x.tol    = 1e-8    # parameter tolerance
#               ))
fit <- optim(obj$par, obj$fn, obj$gr,
method = "BFGS")
est <- fit$par
p1 <- plogis(est["p1_raw"])
p2 <- plogis(est["p2_raw"])
p4 <- plogis(est["p4_raw"])
r  <- plogis(est["r_raw"])
c1 <- 100*plogis(est["logit_c1"])
c2 <- 100*plogis(est["logit_c2"])
c4 <- 100*plogis(est["logit_c4"])
m1 <- 100*plogis(est["logit_m1"])
m2 <- 100*plogis(est["logit_m2"])
m4 <- 100*plogis(est["logit_m4"])
par.est <- c(p1, p2, p4, c1, c2, c4, m1, m2, m4, r)
res.prm <- rbind(res.prm, par.est)
print(j)
}
end_time <- Sys.time()
end_time-start_time
colnames(res.prm) <- c("p1", "p2", "p4", "c1", "c2", "c4",
"m1", "m2", "m4", "r")
res.prm %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
group_by(Variable) %>%
summarise(mean = mean(Value),
median = median(Value),
percentile025 = quantile(Value, probs = 0.025),
percentile975 = quantile(Value, probs = 0.975))
c(p1.true, p2.true, p4.true, c1.true, c2.true, c4.true, m1.true, m2.true, m4.true, r.true, s0.true)
res.prm %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
ggplot(aes(x = "", y = Value)) +
geom_violin(aes(fill = Variable), color = "black") +
geom_boxplot(fill = NA, width = 0.5)+
facet_wrap(~ Variable, scale = "free_y", ncol = 3) +
geom_jitter(width = 0.1, alpha = 0.3) +
theme_minimal() +
labs(title = "Violin Plot for Each Parameter Estimates", x = "",
fill= "Parameters", y = "Estimates")
?optim
res.prm <- data.frame()
start_time <- Sys.time()
for (j in 1:reps) {
sim.data <- data.frame(t = sim.markov$time.steps[sim.markov$reps == j],
Y = sim.markov$ec.steps[sim.markov$reps == j],
M = sim.markov$sc.steps[sim.markov$reps == j] +
sim.markov$dc.steps[sim.markov$reps == j])
data_list <- list(
t = sim.data$t,
M = sim.data$M,
Y = sim.data$Y
)
de.est <- res.de[j,]
parameters <- list(
p1_raw = qlogis(as.numeric(de.est["p1"])),
p2_raw = qlogis(as.numeric(de.est["p2"])),
p4_raw = qlogis(as.numeric(de.est["p4"])),
r_raw  = qlogis(as.numeric(de.est["p1"])),
logit_c1 = qlogis(as.numeric(de.est["c1"]/100)),
logit_c2 = qlogis(as.numeric(de.est["c2"]/100)),
logit_c4 = qlogis(as.numeric(de.est["c4"]/100)),
logit_m1 = qlogis(as.numeric(de.est["m1"]/100)),
logit_m2 = qlogis(as.numeric(de.est["m2"]/100)),
logit_m4 = qlogis(as.numeric(de.est["m4"]/100))
)
obj <- MakeADFun(data_list, parameters, DLL="loglik", silent=TRUE)
# fit <- nlminb(obj$par, obj$fn, obj$gr,
#               control = list(
#                 eval.max = 1000,   # allow more function evaluations
#                 iter.max = 500    # allow more iterations
#                 # rel.tol  = 1e-8,   # convergence tolerance
#                 # x.tol    = 1e-8    # parameter tolerance
#               ))
fit <- optim(obj$par, obj$fn, obj$gr,
method = "BFGS",
control = list(
maxit = 1000
))
est <- fit$par
p1 <- plogis(est["p1_raw"])
p2 <- plogis(est["p2_raw"])
p4 <- plogis(est["p4_raw"])
r  <- plogis(est["r_raw"])
c1 <- 100*plogis(est["logit_c1"])
c2 <- 100*plogis(est["logit_c2"])
c4 <- 100*plogis(est["logit_c4"])
m1 <- 100*plogis(est["logit_m1"])
m2 <- 100*plogis(est["logit_m2"])
m4 <- 100*plogis(est["logit_m4"])
par.est <- c(p1, p2, p4, c1, c2, c4, m1, m2, m4, r)
res.prm <- rbind(res.prm, par.est)
print(j)
}
end_time <- Sys.time()
end_time-start_time
colnames(res.prm) <- c("p1", "p2", "p4", "c1", "c2", "c4",
"m1", "m2", "m4", "r")
res.prm %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
group_by(Variable) %>%
summarise(mean = mean(Value),
median = median(Value),
percentile025 = quantile(Value, probs = 0.025),
percentile975 = quantile(Value, probs = 0.975))
c(p1.true, p2.true, p4.true, c1.true, c2.true, c4.true, m1.true, m2.true, m4.true, r.true, s0.true)
res.prm %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
ggplot(aes(x = "", y = Value)) +
geom_violin(aes(fill = Variable), color = "black") +
geom_boxplot(fill = NA, width = 0.5)+
facet_wrap(~ Variable, scale = "free_y", ncol = 3) +
geom_jitter(width = 0.1, alpha = 0.3) +
theme_minimal() +
labs(title = "Violin Plot for Each Parameter Estimates", x = "",
fill= "Parameters", y = "Estimates")
c(p1.true, p2.true, p4.true, c1.true, c2.true, c4.true, m1.true, m2.true, m4.true, r.true, s0.true)
compile("loglik.cpp")       # compile C++ code
dyn.load(dynlib("loglik"))  # load compiled code
res.prm <- data.frame()
start_time <- Sys.time()
for (j in 1:reps) {
sim.data <- data.frame(t = sim.markov$time.steps[sim.markov$reps == j],
Y = sim.markov$ec.steps[sim.markov$reps == j],
M = sim.markov$sc.steps[sim.markov$reps == j] +
sim.markov$dc.steps[sim.markov$reps == j])
data_list <- list(
t = sim.data$t,
M = sim.data$M,
Y = sim.data$Y
)
de.est <- res.de[j,]
parameters <- list(
p1_raw = qlogis(as.numeric(de.est["p1"])),
p2_raw = qlogis(as.numeric(de.est["p2"])),
p4_raw = qlogis(as.numeric(de.est["p4"])),
r_raw  = qlogis(as.numeric(de.est["p1"])),
logit_c1 = qlogis(as.numeric(de.est["c1"]/100)),
logit_c2 = qlogis(as.numeric(de.est["c2"]/100)),
logit_c4 = qlogis(as.numeric(de.est["c4"]/100)),
logit_m1 = qlogis(as.numeric(de.est["m1"]/100)),
logit_m2 = qlogis(as.numeric(de.est["m2"]/100)),
logit_m4 = qlogis(as.numeric(de.est["m4"]/100))
)
obj <- MakeADFun(data_list, parameters, DLL="loglik", silent=TRUE)
# fit <- nlminb(obj$par, obj$fn, obj$gr,
#               control = list(
#                 eval.max = 1000,   # allow more function evaluations
#                 iter.max = 500    # allow more iterations
#                 # rel.tol  = 1e-8,   # convergence tolerance
#                 # x.tol    = 1e-8    # parameter tolerance
#               ))
fit <- optim(obj$par, obj$fn, obj$gr,
method = "BFGS")
est <- fit$par
p1 <- plogis(est["p1_raw"])
p2 <- plogis(est["p2_raw"])
p4 <- plogis(est["p4_raw"])
r  <- plogis(est["r_raw"])
c1 <- 100*plogis(est["logit_c1"])
c2 <- 100*plogis(est["logit_c2"])
c4 <- 100*plogis(est["logit_c4"])
m1 <- 100*plogis(est["logit_m1"])
m2 <- 100*plogis(est["logit_m2"])
m4 <- 100*plogis(est["logit_m4"])
par.est <- c(p1, p2, p4, c1, c2, c4, m1, m2, m4, r)
res.prm <- rbind(res.prm, par.est)
print(j)
}
end_time <- Sys.time()
end_time-start_time
colnames(res.prm) <- c("p1", "p2", "p4", "c1", "c2", "c4",
"m1", "m2", "m4", "r")
res.prm %>%
pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
group_by(Variable) %>%
summarise(mean = mean(Value),
median = median(Value),
percentile025 = quantile(Value, probs = 0.025),
percentile975 = quantile(Value, probs = 0.975))
c(p1.true, p2.true, p4.true, c1.true, c2.true, c4.true, m1.true, m2.true, m4.true, r.true, s0.true)
res.de <- read.csv("de_res/destep1_start200_025_005_06_065_012_15_010_008_20_02.csv")
res.de <- read.csv("de_res/destep1_start200_055_005_04_015_012_12_020_008_20_02.csv")
fit <- optim(obj$par, obj$fn, obj$gr,
method = "BFGS")
library(TMB)
fit <- optim(obj$par, obj$fn, obj$gr,
method = "BFGS")
obj <- MakeADFun(data_list, parameters, DLL="loglik", silent=TRUE)
dyn.load(dynlib("loglik"))  # load compiled code for automatic differentiation
obj <- MakeADFun(data_list, parameters, DLL="loglik", silent=TRUE)
fit <- optim(obj$par, obj$fn, obj$gr,
method = "BFGS")
