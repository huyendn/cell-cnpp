library(dplyr)
mep_raw <- read.csv("MEP.csv")

mep_tpo <- mep_raw %>%
  filter(Condition =="TPO MEP") %>%
  filter(Parent.Type == "MEP") %>%
  select(Condition, Generation, Parent.Type, First.Frame, Last.Frame,
         First.Time, Last.Time, Daughter.1.Type, Daughter.2.Type,
         Division.Outcome)
df <- mep_tpo

# There are three cells without Division Outcome,
# however, they still have one MEP daughter cell
# and their MEP daughter can be matched.
# Manually label them as MEP Maintenance+E
df[which(df$Division.Outcome == ""),]
df$Division.Outcome[19] <- "MEP Maintenance+E"
df$Division.Outcome[33] <- "MEP Maintenance+E"
df$Division.Outcome[51] <- "MEP Maintenance+E"

## Identifying parent-daughter cells

df$Id <- rep("Empty", nrow(df))
df$Mep.Daughter <- case_when(
  df$Division.Outcome == "MEP Expansion" ~ 2,
  df$Division.Outcome == "MEP Maintenance+E" ~ 1,
  df$Division.Outcome == "MEP Maintenance+Mk" ~ 1,
  df$Division.Outcome == "ErP Expansion" ~ 0,
  df$Division.Outcome == "MEP Exhaustion" ~ 0,
  .default = 0
)


# Checking if the number of MEP daughters generated by 
# each generation matches the number of MEP cells (rows) 
# in the next generation

for (i in 1:(length(unique(df$Generation))-1)) {
  subset_previous_gen <- df%>%filter(Generation == i)
  pos_daughters <- sum(subset_previous_gen$Mep.Daughter)
  count_daughters <- nrow(df%>%filter(Generation == i+1))
  print(paste("Current Gen", i))
  print(paste("Next Gen", i+1))
  print(paste("Daughters by outcome", pos_daughters))
  print(paste("Daughters by count", count_daughters))
  print(pos_daughters == count_daughters)
}

# Labeling generation (G) and number (N) for each cell

mep_start <- nrow(df %>% filter(Generation == 1))
df_label <- df %>% filter(Generation == 1)
for (i in 1:mep_start) {
  df_label$Id[i] <- paste("G1","N",i,sep = "")
}
df_label
generations <- sort(unique(df$Generation))
generations <- generations[-1]
for (i in generations){
  subset_previous <- df_label %>%
    filter(Generation == i-1)
  subset_current <- df %>% 
    filter(Generation == i)
  for (j in 1:nrow(subset_current)){
    kid <- subset_current[j,]
    start_frame <- subset_current$First.Frame[j]
    find_parent <- subset_previous %>%
      filter(Last.Frame == start_frame - 1) %>%
      filter(Mep.Daughter > 0)
    if (nrow(find_parent) >= 1){
      parent_id <- find_parent$Id[1]
      kid_id <- paste("G",i,"N",j, sep = "")
      subset_current$Id[j] <- paste(parent_id,kid_id, sep = "_")
      subset_previous$Mep.Daughter[which(subset_previous$Id == parent_id)] <- subset_previous$Mep.Daughter[which(subset_previous$Id == parent_id)] -1
    }
  }
  subset_current
  df_label <- rbind(df_label, subset_current)
}

# cells that does not have ancestor identified
unique(df_label$Id)
df_label[which(df_label$Id == "Empty"),]
df_label_with_id <- df_label %>% filter(Id != "Empty")

# Extract cell counts for estimation
df_to_extract <- df_label_with_id %>%
  mutate(Type = case_when(Division.Outcome == "MEP Expansion" ~ "MEP Expansion",
                          Division.Outcome == "MEP Maintenance+E" ~ "MEP Maintenance+E",
                          Division.Outcome == "MEP Exhaustion" ~ "MEP Exhaustion",
                          Division.Outcome == "MkP Expansion" ~ "MkP Expansion",
                          Division.Outcome == "ErP Expansion" ~ "ErP Expansion",
                          Division.Outcome == "MEP Maintenance+Mk" ~ "MEP Maintenance+Mk",
                          .default = "No Division")) %>%
  filter(Id != "Empty")
df_to_extract <- df_to_extract[order(df_to_extract$Last.Time),]
time_vec <- c(min(df_to_extract$Last.Time))
mep_vec <- c(nrow(df_to_extract %>% filter(Generation == 1)))
daughter_vec <- c(0)
for (i in 1:nrow(df_to_extract)){
  time_vec <- c(time_vec, df_to_extract$Last.Time[i])
  div_outcome <- df_to_extract$Type[i]
  switch(div_outcome,
         "MEP Expansion" = {
           mep_vec<- c(mep_vec, mep_vec[length(mep_vec)] + 1)
           daughter_vec <- c(daughter_vec, daughter_vec[length(daughter_vec)])
         },
         "ErP Expansion" = {
           mep_vec<- c(mep_vec, mep_vec[length(mep_vec)] - 1)
           daughter_vec <- c(daughter_vec, daughter_vec[length(daughter_vec)] + 2)
         },
         "MkP Expansion" = {
           mep_vec<- c(mep_vec, mep_vec[length(mep_vec)] - 1)
           daughter_vec <- c(daughter_vec, daughter_vec[length(daughter_vec)] + 2)
         },
         "MEP Exhaustion" = {
           mep_vec<- c(mep_vec, mep_vec[length(mep_vec)] - 1)
           daughter_vec <- c(daughter_vec, daughter_vec[length(daughter_vec)] + 2)
         },
         "MEP Maintenance+E"= {
           mep_vec<- c(mep_vec, mep_vec[length(mep_vec)])
           daughter_vec <- c(daughter_vec, daughter_vec[length(daughter_vec)] + 1)
         },
         "MEP Maintenance+Mk"= {
           mep_vec<- c(mep_vec, mep_vec[length(mep_vec)])
           daughter_vec <- c(daughter_vec, daughter_vec[length(daughter_vec)] + 1)
         },
         "No Division"= {
           mep_vec<- c(mep_vec, mep_vec[length(mep_vec)])
           daughter_vec <- c(daughter_vec, daughter_vec[length(daughter_vec)])
         }
  )
}

df_extract <- data.frame(time = time_vec,
                         mep = mep_vec,
                         daughter = daughter_vec)
ggplot(df_extract) +
  geom_point(aes(x = time, y = mep), col = "indianred3") +
  geom_point(aes(x = time , y = daughter), col = "skyblue3")
# write.csv(df_extract)




# df_events <- df_to_extract %>%
#   mutate(
#     time = Last.Time,
#     
#     mep_daughters =
#       (Daughter.1.Type == "MEP") +
#       (Daughter.2.Type == "MEP"),
#     
#     diff_daughters =
#       (Daughter.1.Type != "MEP") +
#       (Daughter.2.Type != "MEP"),
#     
#     # Mother is an MEP and disappears at division
#     MEP_delta  = mep_daughters - 1,
#     Diff_delta = diff_daughters
#   ) %>%
#   select(time, MEP_delta, Diff_delta)
# 
# df_by_time <- df_events %>%
#   group_by(time) %>%
#   summarise(
#     MEP_delta  = sum(MEP_delta),
#     Diff_delta = sum(Diff_delta),
#     .groups = "drop"
#   ) %>%
#   arrange(time)
# 
# initial_MEP <- nrow(df %>% filter(Generation == 1))
# 
# df_counts <- df_by_time %>%
#   mutate(
#     MEP_count = initial_MEP + cumsum(MEP_delta),
#     Diff_count = cumsum(Diff_delta)
#   )
# 
# df_counts
# ggplot(df_counts) +
#   geom_point(aes(x = time, y = MEP_count), col = "indianred3") +
#   geom_point(aes(x = time , y = Diff_count), col = "skyblue3")
# 
# 
# ###
# ###
# ###
# df_events <- df_to_extract %>%
#   mutate(
#     time = Last.Time,
#     
#     mep_daughters =
#       (Daughter.1.Type == "MEP") +
#       (Daughter.2.Type == "MEP"),
#     
#     diff_daughters =
#       (Daughter.1.Type != "MEP") +
#       (Daughter.2.Type != "MEP"),
#     
#     # Net effect of THIS division
#     MEP_delta  = mep_daughters - 1,
#     Diff_delta = diff_daughters
#   ) %>%
#   arrange(time) %>%     # important: chronological order
#   select(Id, time, MEP_delta, Diff_delta)
# 
# initial_MEP <- nrow(df %>% filter(Generation == 1))
# 
# df_event_counts <- df_events %>%
#   mutate(
#     MEP_count  = initial_MEP + cumsum(MEP_delta),
#     Diff_count = cumsum(Diff_delta)
#   )
# View(df_event_counts)
# 
# ggplot(df_event_counts) +
#   geom_point(aes(x = time, y = MEP_count), col = "indianred3") +
#   geom_point(aes(x = time , y = Diff_count), col = "skyblue3")
# 
# plot(c(df_to_extract$First.Frame,df_to_extract$Last.Frame), c(df_to_extract$First.Time, df_to_extract$Last.Time))
# plot(df_to_extract$Last.Frame, df_to_extract$Last.Time)


### estimation
log_likelihood_noduds_de <- function(params, data) {
  params <- as.numeric(params)
  names(params) <- c("u", "v", "c1", "c2", "m1", "m2")
  
  # Reparameterization
  u <- params["u"]
  v <- params["v"]
  
  p1 <- u
  p2 <- (1 - u) * v
  
  c1 <- params["c1"]; c2 <- params["c2"]
  m1 <- params["m1"]; m2 <- params["m2"]
  
  x <- as.numeric(data$X)
  t <- as.numeric(data$t)
  
  A <- p1 / (1 + c1 * (t - m1)^2)
  B <- p2 / (1 + c2 * (t - m2)^2)
  
  epsilon <- 1e-10
  C <- pmax(1 - A - B, epsilon)
  
  ll <- sum(
    (x ==  1) * log(A + epsilon) +
      (x ==  0) * log(B + epsilon) +
      (x == -1) * log(C)
  )
  
  return(-ll)
}

r_estimator <- function(data){
  Si <- data$Si
  deltat <- data$deltat
  n <- nrow(data)
  r <- n/(sum(Si*deltat))
  return(r)
}

### functions for prediction
int.p.func <- function(t, p, c, m) {
  (p / sqrt(c)) * (atan(sqrt(c) * (t - m)) + atan(sqrt(c) * m))
}

make_expected_noduds_data <- function(time.input,
                                      p1.true, c1.true, m1.true,
                                      p2.true, c2.true, m2.true,
                                      # p4.true, c4.true, m4.true,
                                      s0.true, r.true) {
  p1.func <- function(t){
    p1.prob <- p1.true/(1+c1.true*(t-m1.true)^2)
    return(p1.prob)
  }
  
  p2.func <- function(t){
    p2.prob <- p2.true/(1+c2.true*(t-m2.true)^2)
    return(p2.prob)
  }
  
  p3.func <- function(t){
    # p3.prob <- 1- p1.true/(1+c1.true*(t-m1.true)^2)-p2.true/(1+c2.true*(t-m2.true)^2) - p4.true/(1+c4.true*(t-m4.true)^2)
    p3.prob <-1- p1.true/(1+c1.true*(t-m1.true)^2)-p2.true/(1+c2.true*(t-m2.true)^2)
    return(p3.prob)
  }
  
  int.p1 <- function(t) int.p.func(t, p1.true, c1.true, m1.true)
  int.p2 <- function(t) int.p.func(t, p2.true, c2.true, m2.true)
  # int.p4 <- function(t) int.p.func(t, p4.true, c4.true, m4.true)
  
  int.p3 <- function(t) {
    # t - int.p1(t) - int.p2(t) - int.p4(t)
    t - int.p1(t) - int.p2(t)
  }
  
  sc.mean <- function(t) {
    s0.true * exp(r.true * (int.p1(t) - int.p3(t)))
  }
  
  sc.var.bp <- function(t) {
    A <- exp(2 * r.true * (int.p1(t) - int.p3(t)))
    
    integrand_B <- function(x) {
      (p1.func(x) + p3.func(x)) *
        exp(-r.true * (int.p1(x) - int.p3(x)))
    }
    
    B <- integrate(integrand_B, lower = 0, upper = t)$value
    s0.true * r.true * A * B
  }
  ec.mean <- function(t){
    integrand <- function(x){
      (p2.func(x) + 2 * p3.func(x))* exp(r.true * (int.p1(x) - int.p3(x)))
    }
    out <- integrate(integrand, lower = 0, upper = t)$value
    return(out*s0.true*r.true)
  }
  
  data.frame(
    time = time.input,
    sc.mean = sapply(time.input, sc.mean),
    sc.var.bp = sapply(time.input, sc.var.bp),
    ec.mean = sapply(time.input, ec.mean)
  )
}

simulate_markov <- function(
    reps = 100,
    p1, p2, p4,
    c1, c2, c4,
    m1, m2, m4,
    s0 = 200,
    r = 0.2,
    min_p_t = 1e-4,
    max_it = 50000,
    t_max = 100,
    seed = NULL
) {
  if (!is.null(seed)) set.seed(seed)
  
  f_t <- function(t, c, m) 1 / (1 + c * (t - m)^2)
  
  probs_t <- function(t) {
    f1 <- f_t(t, c1, m1)
    f2 <- f_t(t, c2, m2)
    f4 <- f_t(t, c4, m4)
    
    p1t <- p1 * f1
    p2t <- p2 * f2
    p4t <- p4 * f4
    p3t <- 1 - p1t - p2t - p4t
    
    p3t <- pmax(p3t, 0)
    
    probs <- c(p1t, p2t, p3t, p4t)
    
    s <- sum(probs)
    if (s <= 0) stop("All transition probabilities zero â€” invalid parameters.")
    if (s != 1) probs <- probs / s
    
    # avoid extremely small values
    probs[probs < min_p_t] <- 0
    probs <- probs / sum(probs)
    
    probs
  }
  
  all_out <- list()
  idx <- 1
  
  for (rep_i in 1:reps) {
    
    sc <- s0
    ec <- 0
    dc <- 0
    t <- 0
    itnum <- 0
    
    sc_steps <- sc
    ec_steps <- ec
    dc_steps <- dc
    time_steps <- t
    
    while (sc > 0) {
      
      itnum <- itnum + 1
      if (itnum > max_it || t > t_max) {
        warning("Stopped early: max_it or time bound exceeded")
        break
      }
      
      t <- t + rexp(1, rate = r * sc)
      
      probs <- probs_t(t)
      
      event <- sample(1:4, size = 1, prob = probs)
      
      if (event == 1) { sc <- sc + 1 }
      if (event == 2) { ec <- ec + 1 }
      if (event == 3) { sc <- sc - 1; ec <- ec + 2 }
      if (event == 4) { dc <- dc + 1 }
      
      sc_steps <- c(sc_steps, sc)
      ec_steps <- c(ec_steps, ec)
      dc_steps <- c(dc_steps, dc)
      time_steps <- c(time_steps, t)
    }
    
    all_out[[idx]] <- data.frame(
      reps = rep(rep_i, length(sc_steps)),
      time.steps = time_steps,
      sc.steps = sc_steps,
      ec.steps = ec_steps,
      dc.steps = dc_steps
    )
    idx <- idx + 1
  }
  
  do.call(rbind, all_out)
}

### for plotting
colors1 <- c("observed MkP+ErP" = "lightpink", "observed MEP" = "skyblue",
             "estimated MkP+ErP" = "indianred", "estimated MEP" = "darkblue")


###
###
###
mep_tpo_count <- df_extract
# mep_tpo_count <- read.csv("mep_tpo_count.csv")
# mep_tpo_count <- mep_tpo_count[-c(1:4),]

mep_tpo_count$time_shift <- mep_tpo_count$time - min(mep_tpo_count$time)

### TPO
mep_tpo_fitdata <- data.frame(X = diff(mep_tpo_count$mep),
                              t = mep_tpo_count$time_shift[-1],
                              deltat = diff(mep_tpo_count$time_shift),
                              Si = mep_tpo_count$mep
                              [-length(mep_tpo_count$mep)])
head(mep_tpo_fitdata)
t_min <- min(mep_tpo_fitdata$t, 0)
t_max <- max(mep_tpo_fitdata$t, 100)
lower <- c(u = 1e-5, v = 1e-5, 
           c1 = 1e-5, c2 = 1e-5, 
           m1 = t_min, m2 = t_min)
upper <- c(u = 0.99999, v = 0.99999,
           c1 = 100, c2 = 100, 
           m1 = t_max, m2 = t_max)
set.seed(123)
DE_res <- DEoptim(
  fn = log_likelihood_noduds_de,
  lower = lower,
  upper = upper,
  data = mep_tpo_fitdata,
  DEoptim.control(NP = 150, itermax = 600, F = 0.9, CR = 0.8, strategy = 6,
                  trace = FALSE)
)
u_hat <- DE_res$optim$bestmem["u"]
v_hat <- DE_res$optim$bestmem["v"]

p1_hat <- u_hat
p2_hat <- (1 - u_hat) * v_hat

p1_hat; p2_hat

par.est <- DE_res$optim$bestmem
r.est <- r_estimator(mep_tpo_fitdata)
tpo.noduds.est <- c(p1_hat, p2_hat, par.est[3:6], r.est)
names(tpo.noduds.est) <- c("p1", "p2", "c1", "c2", "m1", "m2", "r")
tpo.noduds.est
tpo.noduds.est["p1"]; tpo.noduds.est["c1"]; tpo.noduds.est["m1"]
# 0.4735354   0.0007559984    22.53659
tpo.noduds.est["p2"]; tpo.noduds.est["c2"]; tpo.noduds.est["m2"]
# 0.5264594   0.000148925     29.19082
tpo.noduds.est["r"]
# 0.04583982

p1_fun <- function(t) tpo.noduds.est["p1"] / (1 + tpo.noduds.est["c1"] * (t - tpo.noduds.est["m1"])^2)
p2_fun <- function(t) tpo.noduds.est["p2"] / (1 + tpo.noduds.est["c2"] * (t - tpo.noduds.est["m2"])^2)
p3_fun <- function(t) 1 - p1_fun(t) - p2_fun(t) 
t_vals <- seq(0, 200, length.out = 500)

data <- data.frame(
  t = t_vals,
  p1 = p1_fun(t_vals),
  p2 = p2_fun(t_vals),
  p3 = p3_fun(t_vals)
)

data_long <- pivot_longer(
  data, 
  cols = c(p1, p2, p3), 
  names_to = "Function", 
  values_to = "Value"
)

tpo_prob_plot <- ggplot(data_long, aes(x = t + min(mep_tpo_count$time), y = Value, color = Function)) +
  geom_line(linewidth = 1.2) +
  geom_hline(aes(yintercept = 1)) +
  scale_color_manual(
    values = c("skyblue3", "indianred3", "darkgreen"),
    labels = c(
      expression(p[1](t)),
      expression(p[2](t)),
      expression(p[3](t))
    )
  ) +
  scale_x_continuous(limits = c(20, 200)) +
  labs(
    x = "Time",
    y = "Probability",
    color = "Function",
    subtitle = "Estimated Division Probability Functions"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold"),
    legend.title = element_blank(),
    legend.text.align = 0,
    legend.position = "bottom"
  )

mep_tpo_pred <- make_expected_noduds_data(time.input = seq(min(mep_tpo_count$time_shift), max(mep_tpo_count$time_shift+10), by = 0.1),
                                          p1.true = tpo.noduds.est["p1"],
                                          c1.true = tpo.noduds.est["c1"],
                                          m1.true = tpo.noduds.est["m1"],
                                          p2.true = tpo.noduds.est["p2"],
                                          c2.true = tpo.noduds.est["c2"],
                                          m2.true = tpo.noduds.est["m2"],
                                          s0.true = mep_tpo_count$mep[1],
                                          r.true = tpo.noduds.est["r"])

tpo_est_plot <- ggplot() +
  geom_point(data = mep_tpo_count, 
             aes(x = time_shift + min(time), y = daughter, col = "observed MkP+ErP"),
             pch = 19, size = 2) +
  geom_point(data = mep_tpo_count, 
             aes(x = time_shift+ min(time), y = mep, col = "observed MEP"),
             pch = 19, size = 2) +
  geom_line(data = mep_tpo_pred, 
            aes(x = time + min(mep_tpo_count$time), y = ec.mean, col = "estimated MkP+ErP"),
            linetype = 4, linewidth = 1) +
  geom_line(data = mep_tpo_pred, 
            aes(x = time + min(mep_tpo_count$time), y = sc.mean, col = "estimated MEP"),
            linetype = 4, linewidth = 1) +
  scale_y_continuous(limits = c(-10, 100)) +
  scale_x_continuous(limits = c(20, 200)) +
  labs(x = "Time (in hours)", y = "Cell counts", color = "",
       # title = "Lacking TPO condition",
       subtitle = "Observed and Expected Cell Counts"
  )+
  scale_color_manual(values = colors1) +
  guides(color = guide_legend(nrow = 2, byrow = TRUE))+
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold"),
    legend.title = element_blank(),
    legend.text.align = 0,
    legend.position = "bottom"
  )

(tpo_prob_plot | tpo_est_plot) +  plot_annotation(
  title = "Lacking TPO Condition"
) &
  theme(
    plot.title = element_text(size = 14, face = "bold")
  )

sim.tpo.est.dat <- simulate_markov(reps = 50, 
                                   p1 = tpo.noduds.est["p1"], p2 = tpo.noduds.est["p2"], p4 = 0,
                                   c1 = tpo.noduds.est["c1"], c2 = tpo.noduds.est["c2"], c4 = 1,
                                   m1 = tpo.noduds.est["m1"], m2 = tpo.noduds.est["m2"], m4 = 1,
                                   s0 = mep_tpo_count$mep[1], r = tpo.noduds.est["r"], seed = 123, 
                                   t_max = max(mep_tpo_count$time+10))

tpo_ec_plot <- ggplot() +
  geom_line(data = sim.tpo.est.dat, 
            aes(x = time.steps+ min(mep_tpo_count$time), y = ec.steps, group = reps), 
            size = 0.02, alpha = 0.2)+
  geom_point(data = mep_tpo_count, 
             aes(x = time_shift+ min(mep_tpo_count$time), y = daughter, col = "observed MkP+ErP"),
             pch = 19, size = 2) +
  # geom_point(data = mep_tpo_count, 
  #            aes(x = time_shift+ min(mep_tpo_count$time), y = mep, col = "observed MEP"),
  #            pch = 19, size = 2) +
  geom_line(data = mep_tpo_pred, 
            aes(x = time + min(mep_tpo_count$time), y = ec.mean, col = "estimated MkP+ErP"),
            linetype = 4, linewidth = 1) +
  # geom_line(data = mep_tpo_pred, 
  #           aes(x = time + min(mep_tpo_count$time), y = sc.mean, col = "estimated MEP"),
  #           linetype = 4, linewidth = 1) +
  scale_y_continuous(limits = c(-10, 100)) +
  scale_x_continuous(limits = c(20, 200)) +
  labs(x = "Time (in hours)", y = "Cell counts", color = "",
       subtitle = "MkP + ErP"
  )+
  scale_color_manual(values = colors1) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold"),
    legend.title = element_blank(),
    legend.text.align = 0,
    legend.position = "bottom"
  )

tpo_sc_plot <-ggplot() +
  geom_line(data = sim.tpo.est.dat, 
            aes(x = time.steps+ min(mep_tpo_count$time), y = sc.steps, group = reps), 
            size = 0.02, alpha = 0.2)+
  # geom_point(data = mep_tpo_count, 
  #            aes(x = time_shift+ min(mep_tpo_count$time), y = daughter, col = "observed MkP+ErP"),
  #            pch = 19, size = 2) +
  geom_point(data = mep_tpo_count,
             aes(x = time_shift+ min(mep_tpo_count$time), y = mep, col = "observed MEP"),
             pch = 19, size = 2) +
  # geom_line(data = mep_tpo_pred, 
  #           aes(x = time + min(mep_tpo_count$time), y = ec.mean, col = "estimated MkP+ErP"),
  #           linetype = 4, linewidth = 1) +
  geom_line(data = mep_tpo_pred,
            aes(x = time + min(mep_tpo_count$time), y = sc.mean, col = "estimated MEP"),
            linetype = 4, linewidth = 1) +
  geom_ribbon(data = mep_tpo_pred, 
              aes(x = time + min(mep_tpo_count$time), 
                  ymax = sc.mean + 2*sqrt(sc.var.bp), 
                  ymin = sc.mean-2*sqrt(sc.var.bp)),
              fill = "skyblue", alpha = 0.3) +
  scale_y_continuous(limits = c(-10, 100)) +
  scale_x_continuous(limits = c(20, 200)) +
  labs(x = "Time (in hours)", y = "Cell counts", color = "",
       subtitle = "MEP"
  )+
  scale_color_manual(values = colors1) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold"),
    legend.title = element_blank(),
    legend.text.align = 0,
    legend.position = "bottom"
  )
(tpo_sc_plot | tpo_ec_plot) +  plot_annotation(
  title = "Lacking TPO Condition"
) &
  theme(
    plot.title = element_text(size = 14, face = "bold")
  )
##
##
